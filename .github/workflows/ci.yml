name: CI

on:
  push:
    branches: ['**']
    tags: ['*']
  pull_request:

jobs:
  init:
    name: "Init step"
    runs-on: ubuntu-latest
    outputs:
      docker_files: ${{ steps.collect_docker.outputs.docker_files }}
      module_dirs: ${{ steps.collect_docker.outputs.module_dirs }}
      modules_for_tests: ${{ steps.collect_modules_tests.outputs.modules_for_tests }}
      image_tag: ${{ steps.compute_tag.outputs.image_tag }}

    steps:
      - uses: actions/checkout@v4
      - name: Collect Dockerfiles and module directories to build
        id: collect_docker
        run: |
          files=$(git ls-files '*/Dockerfile')
          if [ -z "$files" ]; then
            echo "docker_files=[]" >> "$GITHUB_OUTPUT"
            echo "module_dirs=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          docker_files=$(printf '%s\n' "$files" | jq -R -s -c 'split("\n")[:-1]')
          module_dirs=$(printf '%s\n' "$files" | xargs -n1 dirname | sort -u | jq -R -s -c 'split("\n")[:-1]')
          echo "docker_files=$docker_files" >> "$GITHUB_OUTPUT"
          echo "module_dirs=$module_dirs" >> "$GITHUB_OUTPUT"
      - name: Init modules for Tests
        id: collect_modules_tests
        run: |
          modules_for_tests='["api-gateway","frontend"]'
          echo "modules_for_tests=$modules_for_tests" >> "$GITHUB_OUTPUT"
      - name: Compute image tag
        id: compute_tag
        run: |
          # tag_name="test"
          git_tag_name="${GITHUB_REF_NAME}"
          tag_date="$(date +'%d%m%y')"
          image_tag="${git_tag_name}-${tag_date}"
          echo "image_tag=$image_tag" >> "$GITHUB_OUTPUT"

  tests:
    name: Run Unit Tests
    needs: init
    runs-on: ubuntu-latest
    if: ${{ needs.init.outputs.modules_for_tests != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        module: ${{ fromJson(needs.init.outputs.modules_for_tests) }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            ${{ matrix.module }}
          sparse-checkout-cone-mode: false
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.module }}/package-lock.json
      - name: Install
        run: npm ci
        working-directory: ${{ matrix.module }}
      - name: Run unit tests
        run: npm run test:unit
        working-directory: ${{ matrix.module }}

  validate:
    name: Validate Dockerfiles
    runs-on: ubuntu-latest
    needs: init
    if: ${{ needs.init.outputs.docker_files != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        dockerfile: ${{ fromJson(needs.init.outputs.docker_files) }}
    steps:
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            ${{ matrix.dockerfile }}
          sparse-checkout-cone-mode: false
      - name: Lint Dockerfile
        run: docker run --rm -i hadolint/hadolint hadolint --failure-threshold error - < "${{ matrix.dockerfile }}"

  build:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [init, tests, validate]
    if: ${{ startsWith(github.ref, 'refs/tags/') && needs.init.outputs.module_dirs != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        dir: ${{ fromJson(needs.init.outputs.module_dirs) }}
    steps:
      - uses: actions/checkout@v4
      - name: Build Image
        env:
          REGISTRY_URL: ${{ secrets.SECRET_GITHUB_REGISTRY_URL }}
        run: |
          image_tag="${{ needs.init.outputs.image_tag }}"
          safe_dir="${{ matrix.dir }}"
          safe_dir="${safe_dir//\//-}"
          image_name="${REGISTRY_URL}/final-project-${safe_dir}"
          echo "Building image for ${image_name}:${image_tag}"
          docker build -t "${image_name}:${image_tag}" -f "${{ matrix.dir }}/Dockerfile" "${{ matrix.dir }}"
      - name: Push Image
        env:
          REGISTRY_URL: ${{ secrets.SECRET_GITHUB_REGISTRY_URL }}
          REGISTRY_USERNAME: ${{ secrets.SECRET_GITHUB_REGISTRY_USERNAME }}
          REGISTRY_TOKEN: ${{ secrets.SECRET_GITHUB_REGISTRY_TOKEN }}
        run: |
          echo "$REGISTRY_TOKEN" | docker login "$REGISTRY_URL" -u "$REGISTRY_USERNAME" --password-stdin
          image_tag="${{ needs.init.outputs.image_tag }}"
          safe_dir="${{ matrix.dir }}"
          safe_dir="${safe_dir//\//-}"
          image_name="${REGISTRY_URL}/final-project-${safe_dir}"
          echo "Pushing image ${image_name}:${image_tag}"
          docker push "${image_name}:${image_tag}"

  integration_test:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Smoke test images
        env:
          REGISTRY_URL: ${{ secrets.SECRET_GITHUB_REGISTRY_URL }}
        run: |
          image_tag="${{ needs.init.outputs.image_tag }}"
          export REGISTRY_URL IMAGE_TAG="$image_tag"
          chmod +x scripts/ci_smoke.sh
          docker compose -f docker-compose.ci.yml up -d --pull=always
          ./scripts/ci_smoke.sh
          docker compose -f docker-compose.ci.yml down -v

  update_helm:
    name: Update Helm Repo
    runs-on: ubuntu-latest
    needs: integration_test
    outputs:
      chart_version: ${{ steps.update_chart.outputs.chart_version }}
    steps:
      - name: Checkout helm repo
        uses: actions/checkout@v4
        with:
          repository: romastelchenko/it-academy.00.final-project-helm
          token: ${{ secrets.SECRET_GITHUB_HELM_REPO_TOKEN }}
      - name: Setup Helm
        uses: azure/setup-helm@v4
      - name: Update Chart.yaml appVersion
        id: update_chart
        run: |
          image_tag="${{ needs.init.outputs.image_tag }}"
          chart_dir="helm-sources/football-app"
          if [ ! -f "${chart_dir}/Chart.yaml" ]; then
            echo "Chart.yaml not found"
            exit 1
          fi
          sed -i -E "s/^appVersion:.*/appVersion: \"${image_tag}\"/" "${chart_dir}/Chart.yaml"
          current_version=$(grep -E '^version:' "${chart_dir}/Chart.yaml" | awk '{print $2}' | tr -d '"')
          IFS='.' read -r major minor patch <<< "$current_version"
          patch=$((patch + 1))
          chart_version="${major}.${minor}.${patch}"
          sed -i -E "s/^version:.*/version: \"${chart_version}\"/" "${chart_dir}/Chart.yaml"
          echo "Updated appVersion to ${image_tag}"
          echo "Updated version to ${chart_version}"
          echo "chart_version=${chart_version}" >> "$GITHUB_OUTPUT"
      - name: Package chart and update index
        run: |
          chart_dir="helm-sources/football-app"
          releases_dir="helm-releases"
          repo_url="https://romastelchenko.github.io/it-academy.00.final-project-helm/helm-releases"
          mkdir -p "${releases_dir}"
          helm package "${chart_dir}" -d "${releases_dir}"
          if [ -f "${releases_dir}/index.yaml" ]; then
            helm repo index "${releases_dir}" --url "${repo_url}" --merge "${releases_dir}/index.yaml"
          else
            helm repo index "${releases_dir}" --url "${repo_url}"
          fi
      - name: Commit and push
        run: |
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          git config user.email "github-actions@users.noreply.github.com"
          git config user.name "github-actions"
          git add helm-sources/football-app/Chart.yaml helm-releases/index.yaml helm-releases/*.tgz
          git commit -m "[GITHUB ACTION: NEW HELM CHART] update appVersion to ${{ needs.init.outputs.image_tag }}"
          git push

  notify_with_results:
    runs-on: ubuntu-latest
    needs: [init, tests, validate, build, integration_test, update_helm]
    if: always()
    steps:
      - name: Collect job results
        id: job_results
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.runId;
            const { data } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
              per_page: 100,
            });
            const results = [];
            const aggregate = {};
            for (const job of data.jobs) {
              if (job.name === 'Send slack notification') {
                continue;
              }
              let seconds = null;
              if (job.started_at && job.completed_at) {
                const start = new Date(job.started_at).getTime();
                const end = new Date(job.completed_at).getTime();
                seconds = Math.max(0, Math.round((end - start) / 1000));
              }
              results.push({
                name: job.name,
                status: job.conclusion || job.status,
                duration: seconds,
              });

              if (!aggregate[job.name]) {
                aggregate[job.name] = {
                  name: job.name,
                  status: job.conclusion || job.status,
                  started_at: job.started_at,
                  completed_at: job.completed_at,
                };
              } else {
                const entry = aggregate[job.name];
                entry.started_at = entry.started_at && job.started_at
                  ? (new Date(entry.started_at) < new Date(job.started_at) ? entry.started_at : job.started_at)
                  : entry.started_at || job.started_at;
                entry.completed_at = entry.completed_at && job.completed_at
                  ? (new Date(entry.completed_at) > new Date(job.completed_at) ? entry.completed_at : job.completed_at)
                  : entry.completed_at || job.completed_at;
                if (entry.status !== 'failure' && (job.conclusion || job.status) === 'failure') {
                  entry.status = 'failure';
                }
              }
            }
            const aggregatedResults = Object.values(aggregate).map((entry) => {
              let duration = null;
              if (entry.started_at && entry.completed_at) {
                const start = new Date(entry.started_at).getTime();
                const end = new Date(entry.completed_at).getTime();
                duration = Math.max(0, Math.round((end - start) / 1000));
              }
              return {
                name: entry.name,
                status: entry.status,
                duration,
              };
            });
            core.setOutput('results', JSON.stringify(aggregatedResults));

      - name: Send slack notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SECRET_SLACK_WEBHOOK_URL }}
          RESULTS_JSON: ${{ steps.job_results.outputs.results }}
          IMAGE_TAG: ${{ needs.init.outputs.image_tag }}
          CHART_VERSION: ${{ needs.update_helm.outputs.chart_version }}
          HELM_JOB_RESULT: ${{ needs.update_helm.result }}
          BUILD_JOB_RESULT: ${{ needs.build.result }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          status_emoji() {
            case "$1" in
              success) echo "ðŸŸ¢" ;;
              failure) echo "ðŸ”´" ;;
              skipped) echo "âšª" ;;
              *) echo "ðŸŸ¡" ;;
            esac
          }
          format_job_result() {
            local name="$1"
            local status="$2"
            local duration="$3"
            local emoji=$(status_emoji "$status")
            if [ -n "$duration" ] && [ "$duration" != "null" ]; then
              printf "%s: %s %s (%ss)\n" "$name" "$emoji" "$status" "$duration"
            else
              printf "%s: %s %s\n" "$name" "$emoji" "$status"
            fi
          }
          message="CI results for ${GITHUB_REPOSITORY} @ ${GITHUB_REF_NAME}\n"
          message+="Run: ${RUN_URL}\n"
          if [ "$BUILD_JOB_RESULT" = "success" ]; then
            message+="New Docker Images tag: ${IMAGE_TAG}\n"
          fi
          if [ "$HELM_JOB_RESULT" = "success" ] && [ -n "$CHART_VERSION" ]; then
            message+="New Helm chart version: ${CHART_VERSION}\n"
          fi
          message+="\nJob details:\n"
          lines=$(echo "$RESULTS_JSON" | jq -r '.[] | [.name, .status, .duration] | @tsv')
          while IFS=$'\t' read -r name status duration; do
            message+=$(format_job_result "$name" "$status" "$duration")
          done <<< "$lines"
          message_body_pattern='{"text":"%s"}'
          message_body=$(printf "${message_body_pattern}" "${message}")
          curl -X POST -H 'Content-type: application/json' --data "${message_body}" ${SLACK_WEBHOOK_URL}
